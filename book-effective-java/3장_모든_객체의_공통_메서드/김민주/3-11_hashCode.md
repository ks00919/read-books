## 아이템 11. `equals`를 재정의하려거든 `hashCode`도 재정의하라

> equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.

- 위 규약은 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다는 것이다.
- `hashCode`를 재정의하지 않는다면 `Object`의 기본 `hashCode`는 논리적으로 같은 두 객체를 다르다고 판단하여 서로 다른 값을 반환한다.

### 올바른 해시코드 구현

#### 잘못된 예시

```java
@Override public int hashCode() { return 42; }
```

- 모든 객체에 같은 값을 넘겨주게 되면 실제로는 해시 테이블이 연결 리스트처럼 동작한다.
  - 평균 수행 시간 : O(n)

#### 좋은 `hashCode` 작성 요령

1. `int` 변수 `result`를 선언한 후 값 `c`로 초기화
2. 해당 객체의 나머지 핵심 필드 `f` 각각에 다음 작업을 수행한다.
   1. 해당 필드의 해시코드 `c`를 계산
   2. 계산한 해시코드 `c`로 `result`를 갱신 (`result = 31 * result + c`)
3. `result` 반환

- 다른 필드로부터 계산해낼 수 있는 필드(파생 필드)는 제외해도 된다.
- `equals`에 사용되지 않은 필드는 **반드시** 제거해야 한다.
- `31 * result`는 곱하는 순서에 따라서 `result` 값이 달라진다.

  - 31인 이유는 홀수이면서 소수이기 때문이다.
  - 2를 곱하는 것은 시프트 연산과 같은 결과를 내기 때문에 홀수로 해야한다.
  - 소수인 것은 전통적으로 그래왔다.
  - `31 * i`는 `(i << 5) - i`로 최적화할 수 있다.

- 클래스가 불변이고 해시코드를 계산하는 비용이 크다면 캐싱을 고려하자.
- **성능을 개선한다고 핵심 필드를 생략해서는 안된다.**
- **`hashCode` 생성 규칙을 API 사용자에게 자세히 공표하지 말자.**
  - 클라이언트가 값에 의지하지 않음
  - 추후에 계산 방식을 바꿀 수 있음
